#include "ScheiderTraction.h"

registerMooseObject("TensorMechanicsApp", ScheiderTraction);

InputParameters
ScheiderTraction::validParams()
{
  InputParameters params = CZMComputeLocalTractionTotalBase::validParams();
  params.addClassDescription("Scheider cohesive law");
  params.addRequiredParam<Real>(
      "normal_gap_at_maximum_normal_traction",
      "The value of normal gap at which maximum normal traction is achieved");
  params.addRequiredParam<Real>(
      "tangential_gap_at_maximum_shear_traction",
      "The value of tangential gap at which maximum shear traction is achieved");
  params.addRequiredParam<Real>("maximum_normal_traction",
                                "The maximum normal traction the interface can sustain");
  params.addRequiredParam<Real>("maximum_shear_traction",
                                "The maximum shear traction the interface can sustain");
  return params;
}

ScheiderTraction::ScheiderTraction(const InputParameters & parameters)
  : CZMComputeLocalTractionTotalBase(parameters),
    _delta_u0({getParam<Real>("normal_gap_at_maximum_normal_traction"),
               getParam<Real>("tangential_gap_at_maximum_shear_traction"),
               getParam<Real>("tangential_gap_at_maximum_shear_traction")}),
    _max_allowable_traction({getParam<Real>("maximum_normal_traction"),
                             getParam<Real>("maximum_shear_traction"),
                             getParam<Real>("maximum_shear_traction")})
{
}

void
ScheiderTraction::computeInterfaceTractionAndDerivatives()
{
  _interface_traction[_qp] = computeTraction();
  _dinterface_traction_djump[_qp] = computeTractionDerivatives();
}

RealVectorValue
ScheiderTraction::computeTraction()
{
    
    RealVectorValue traction_local;
    
    unsigned int i;
    
    for (i = 0; i < 3; i++)
    {
        
        if (_interface_displacement_jump[_qp](i) >= 0)
        {
            if (_interface_displacement_jump[_qp](i) <= 0.01*_delta_u0(i))
            {
                traction_local(i) = _max_allowable_traction(i) * (_interface_displacement_jump[_qp](i)/(0.01*_delta_u0(i)));
            }
           
            else if (_interface_displacement_jump[_qp](i) > 0.01*_delta_u0(i) && _interface_displacement_jump[_qp](i) <= 1*_delta_u0(i))
            {
                traction_local(i) = _max_allowable_traction(i) * ((_delta_u0(i)-_interface_displacement_jump[_qp](i))/(0.01*_delta_u0(i) - _delta_u0(i)));
            }
            else
                
            {
                traction_local(i) = 0.0000001*_interface_displacement_jump[_qp](i);
            }
        }
        
        else
        {
            if (_interface_displacement_jump[_qp](i) >= -0.01*_delta_u0(i))
            {
                traction_local(i) = _max_allowable_traction(i) * (_interface_displacement_jump[_qp](i)/(0.01*_delta_u0(i)));
            }
           
            else if (_interface_displacement_jump[_qp](i) < -0.01*_delta_u0(i) && _interface_displacement_jump[_qp](i) >= -1*_delta_u0(i))
            {
                traction_local(i) = _max_allowable_traction(i) * ((_delta_u0(i)-_interface_displacement_jump[_qp](i))/(0.01*_delta_u0(i) - _delta_u0(i)));
            }
            else
                
            {
                traction_local(i) = 0.0000001*_interface_displacement_jump[_qp](i);
            }
        }
            
    }

  return traction_local;
}

RankTwoTensor
ScheiderTraction::computeTractionDerivatives()
{
  RankTwoTensor traction_jump_derivatives_local;
    
  unsigned int i, j;
    
    for (i = 0; i < 3; i++)
    {
            for (j = 0; j < 3; j++)
            {
                if (_interface_displacement_jump[_qp](j) <= 0)
                    if (i == j)
                    {
                        if (_interface_displacement_jump[_qp](j) <= 0.01*_delta_u0(i))
                        {
                            traction_jump_derivatives_local(i, j) = _max_allowable_traction(i)/(0.01*_delta_u0(i));
                        }
                        
                        else if (_interface_displacement_jump[_qp](j) >= 0.01*_delta_u0(i) && _interface_displacement_jump[_qp](j) <= 1*_delta_u0(i))
                        {
                            traction_jump_derivatives_local(i, j) = _max_allowable_traction(i)/(0.01*_delta_u0(i) - _delta_u0(i));
                        }
                        else
                        {
                            traction_jump_derivatives_local(i, j) = 0.0000001;
                        }
                    }
                    else
                        traction_jump_derivatives_local(i, j) = 0.0;
                
                else
                    if (i == j)
                    {
                        if (_interface_displacement_jump[_qp](j) >= -0.01*_delta_u0(i))
                        {
                            traction_jump_derivatives_local(i, j) = _max_allowable_traction(i)/(0.01*_delta_u0(i));
                        }
                        
                        else if (_interface_displacement_jump[_qp](j) < -0.01*_delta_u0(i) && _interface_displacement_jump[_qp](j) >= -1*_delta_u0(i))
                        {
                            traction_jump_derivatives_local(i, j) = _max_allowable_traction(i)/(0.01*_delta_u0(i) - _delta_u0(i));
                        }
                        else
                        {
                            traction_jump_derivatives_local(i, j) = -0.0000001;
                        }
                    }
                    else
                        traction_jump_derivatives_local(i, j) = 0.0;
                
            }
        }

      return traction_jump_derivatives_local;
}
